"""
Aca van a estar todos los ejerecicios.
El formato es `def problema_x():` donde x es el numero del problema en la pag projecteuler.net.
Cada problema va a tener un comentario inicial explicando el problema.
Despues puedo ir agregando cuantos comments mas crea necesario.
"""
from bisect import bisect_left
import math
from itertools import (
    permutations,
    combinations
)
import pyperclip
import os

from utils.utils import (
    check_all_digits,
    check_if_all_digits_are_the_same,
    find_cyclic_length,
    generate_rotation_nums,
    get_digits,
    get_loop_range,
    get_lowest_common_term,
    get_total_factors,
    is_palindrome,
    is_palindrome_number,
    is_prime,
    is_prime_2,
    lowest_common_multiple,
    p,
    run_cpu_tasks_in_parallel,
    sum_factors,
)


def problema_1():
    """
    If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
    Find the sum of all the multiples of 3 or 5 below 1000.

    Si sumo los multiplos de 3 y los multiplos de 5 voy a tener todos los numeros.
    Dps tengo que restar los multiplos de 15 porque estan repetidos
    Como esas 3 tareas son independientes podria hacer que cada una corra en una CPU separada
    """
    def multiplos_3():
        return sum(i for i in range(3, 1000, 3))
                   
    def multiplos_5():
        return sum(i for i in range(5, 1000, 5))
                   
    def multiplos_15():
        return sum(i for i in range(15, 1000, 15))
                   
    tasks = [multiplos_3, multiplos_5, multiplos_15]
    results = run_cpu_tasks_in_parallel(tasks)
    return sum(results)


def problema_2():
    """
    Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
        1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
    By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

    100% secuencial, python no tiene problemas con el int maximo, es unsigned.
    """
    n1, n2 = 1, 2
    total = 0

    while n1 <= 4000000:
        if n1 % 2 == 0:
            total += n1
        n1, n2 = n2, n1 + n2
    return total

def problema_3():
    """
    The prime factors of 13195 are 5, 7, 13 and 29.
    What is the largest prime factor of the number 600851475143 ?

    Reduciendo el numero yendo de factor mas chico a factor mas grande. En el ultimo paso siempre va a quedar el factor mas grande
    """
    n = 600851475143
    factor = 1
    initial = 2

    while n > 1:
        while n % initial != 0:
            if initial == 2:
                initial += 1
            else:
                initial += 2
        factor = initial
        n /= factor

    return factor


def problema_4():
    """
    Find the largest palindrome made from the product of two 3-digit numbers.

    """
    maximo = 0
    for i in range(999, 99, -1):
        for j in range(999, 99, -1):
            if p(i * j):
                maximo = max(maximo, i * j)
            elif maximo > i*j:
                break
    return maximo


def problema_5():
    """
    2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
    What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?

    Aplicar multiplo comun en un loop hasta el fin de la secuencia
    """
    start = 1
    for i in range(2, 21):
        print("{} == {} == {}".format(i, start, lowest_common_multiple(start, i)))
        start = lowest_common_multiple(start, i)


    return start


def problema_6():
    """
    The sum of the squares of the first ten natural numbers is 385,
    The square of the sum of the first ten natural numbers is 3025,
    Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 2640.
    Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.

    """
    sum_of_the_sq = sum(i ** 2 for i in range(101))
    sq_of_the_sum = sum(i for i in range(101)) ** 2
    return sq_of_the_sum - sum_of_the_sq


def problema_7():
    """
    By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
    What is the 10 001st prime number?


    """
    cnt = 1
    num = 3
    while True:
        if is_prime(num):
            cnt += 1
        if cnt == 10001:
            break
        num += 2

    return num


def problema_8():
    n = "731671765313306249192251196744265747423553491949349698352031277450632623957831801698480186947885184385861560789" \
        "112949495459501737958331952853208805511125406987471585238630507156932909632952274430435576689664895044524452316" \
        "173185640309871112172238311362229893423380308135336276614282806444486645238749303589072962904915604407723907138" \
        "105158593079608667017242712188399879790879227492190169972088809377665727333001053367881220235421809751254540594" \
        "752243525849077116705560136048395864467063244157221553975369781797784617406495514929086256932197846862248283972" \
        "241375657056057490261407972968652414535100474821663704844031998900088952434506585412275886668811642717147992444" \
        "292823086346567481391912316282458617866458359124566529476545682848912883142607690042242190226710556263211111093" \
        "705442175069416589604080719840385096245544436298123098787992724428490918884580156166097919133875499200524063689" \
        "9125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450"

    def _prod(arr, i):
        tot = 1
        for p in arr[i: i+13]:
            tot *= int(p)
        return tot

    def can_prod(arr, i):
        for p in arr[i: i+13]:
            if p == "0":
                return False
        return True

    def find_0(arr, i):
        for j in range(i, len(arr)):
            if arr[j] == "0":
                return j + 1
        return len(arr)

    tot = _prod(n, 0)
    maximo = tot
    index = 13
    
    while index < len(n):
        mult = int(n[index])

        if mult == 0:
            while not can_prod(n, index):
                index = find_0(n, index)
                if len(n) == index:
                    return maximo
            tot = _prod(n, index)
            index += 13

        else:
            tot *= mult
            tot = tot // int(n[index - 13])
            index += 1

        maximo = max(tot, maximo)

    return maximo

def problema_9():
    """
    A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,
    a^2 + b^2 = c^2
    For example, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.
    There exists exactly one Pythagorean triplet for which a + b + c = 1000.
    Find the product abc.

    a < b < c && a + b + c = 1000 && c^2 = a^2 + b^2

    1 2 997
    1 3 996
    1 4 995
    ...
    2 3
    """
    pos = 997
    for i in range(1, pos-2):
        for j in range(i+1, pos-1):
            k = 1000 - i - j
            if i > k or j > k:
                break
            if i ** 2 + j ** 2 == k ** 2:
                return i * j * k


def problema_10():
    """
    The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
    Find the sum of all the primes below two million.

    La idea es tener un array con los primos generados on the fly e ir chequeando contra esos solamente.
    Si es primo se agrega al array y sino es se corta. Checkear hasta sqrt(n), innecesario checkear mas que eso por num.
    """
    total = 2
    primes_so_far = [2]
    for i in range(3, 2000000, 2):
        if is_prime_2(i, primes_so_far):
            total += i

    return total

def problema_11():
    """

    """

    grid = [
        [8, 2, 22, 97, 38, 15, 0, 40, 0, 75, 4, 5, 7, 78, 52, 12, 50, 77, 91, 8],
        [49, 49, 99, 40, 17, 81, 18, 57, 60, 87, 17, 40, 98, 43, 69, 48, 4, 56, 62, 0],
        [81, 49, 31, 73, 55, 79, 14, 29, 93, 71, 40, 67, 53, 88, 30, 3, 49, 13, 36, 65],
        [52, 70, 95, 23, 4, 60, 11, 42, 69, 24, 68, 56, 1, 32, 56, 71, 37, 2, 36, 91],
        [22, 31, 16, 71, 51, 67, 63, 89, 41, 92, 36, 54, 22, 40, 40, 28, 66, 33, 13, 80],
        [24, 47, 32, 60, 99, 3, 45, 2, 44, 75, 33, 53, 78, 36, 84, 20, 35, 17, 12, 50],
        [32, 98, 81, 28, 64, 23, 67, 10, 26, 38, 40, 67, 59, 54, 70, 66, 18, 38, 64, 70],
        [67, 26, 20, 68, 2, 62, 12, 20, 95, 63, 94, 39, 63, 8, 40, 91, 66, 49, 94, 21],
        [24, 55, 58, 5, 66, 73, 99, 26, 97, 17, 78, 78, 96, 83, 14, 88, 34, 89, 63, 72],
        [21, 36, 23, 9, 75, 0, 76, 44, 20, 45, 35, 14, 0, 61, 33, 97, 34, 31, 33, 95],
        [78, 17, 53, 28, 22, 75, 31, 67, 15, 94, 3, 80, 4, 62, 16, 14, 9, 53, 56, 92],
        [16, 39, 5, 42, 96, 35, 31, 47, 55, 58, 88, 24, 0, 17, 54, 24, 36, 29, 85, 57],
        [86, 56, 0, 48, 35, 71, 89, 7, 5, 44, 44, 37, 44, 60, 21, 58, 51, 54, 17, 58],
        [19, 80, 81, 68, 5, 94, 47, 69, 28, 73, 92, 13, 86, 52, 17, 77, 4, 89, 55, 40],
        [4, 52, 8, 83, 97, 35, 99, 16, 7, 97, 57, 32, 16, 26, 26, 79, 33, 27, 98, 66],
        [88, 36, 68, 87, 57, 62, 20, 72, 3, 46, 33, 67, 46, 55, 12, 32, 63, 93, 53, 69],
        [4, 42, 16, 73, 38, 25, 39, 11, 24, 94, 72, 18, 8, 46, 29, 32, 40, 62, 76, 36],
        [20, 69, 36, 41, 72, 30, 23, 88, 34, 62, 99, 69, 82, 67, 59, 85, 74, 4, 36, 16],
        [20, 73, 35, 29, 78, 31, 90, 1, 74, 31, 49, 71, 48, 86, 81, 16, 23, 57, 5, 54],
        [1, 70, 54, 71, 83, 51, 54, 69, 16, 92, 33, 48, 61, 43, 52, 1, 89, 19, 67, 48],
    ]
    rows = len(grid)
    cols = len(grid[0])

    def check(a, b):
        return a + 3 < b

    def check_diag1(i, j, r, c):
        return i + 3 < r and j + 3 < c

    def check_diag2(i, j, r):
        return i + 3 < r and j - 3 > 0

    maximo = 0

    for row_i in range(cols):
        for col_i in range(rows):
            if check(col_i, cols):
                suma = grid[row_i][col_i] * grid[row_i][col_i + 1] * grid[row_i][col_i + 2] * grid[row_i][col_i + 3]
                maximo = max(maximo, suma)
            if check(row_i, rows):
                suma = grid[row_i][col_i] * grid[row_i + 1][col_i] * grid[row_i + 2][col_i] * grid[row_i + 3][col_i]
                maximo = max(maximo, suma)
            if check_diag1(row_i, col_i, rows, cols):
                suma = grid[row_i][col_i] * grid[row_i + 1][col_i + 1] * grid[row_i + 2][col_i + 2] * grid[row_i + 3][col_i + 3]
                maximo = max(maximo, suma)
            if check_diag2(row_i, col_i, rows):
                suma = grid[row_i][col_i] * grid[row_i + 1][col_i - 1] * grid[row_i + 2][col_i - 2] * grid[row_i + 3][col_i - 3]
                maximo = max(maximo, suma)

    return maximo


def problema_12():
    """
    The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
    1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

    Let us list the factors of the first seven triangle numbers:

     1: 1
     3: 1,3
     6: 1,2,3,6
    10: 1,2,5,10
    15: 1,3,5,15
    21: 1,3,7,21
    28: 1,2,4,7,14,28
    We can see that 28 is the first triangle number to have over five divisors.

    What is the value of the first triangle number to have over five hundred divisors?

     Primero generarlos = OK
     Checkear cuantos divisores tiene cada numero.
    """

    i = 1
    total = 0

    while True:
        total += i
        if get_total_factors(total) > 500:
            return total
        i += 1


def problema_13():
    """
    Work out the first ten digits of the sum of the following one-hundred 50-digit numbers.

    Como el num es muy grande va a estar copiado y lo pego usando una libreria externa,
    el problema es bastante simple sacando eso
    url para buscar el chorizo horrible: https://projecteuler.net/problem=13
    """
    huge_number = pyperclip.paste()
    huge_number = huge_number.split("\n")
    tot = 0

    for block in huge_number:
        tot += int(block)
    return str(tot)[:10]

def problema_14():
    """
    The following iterative sequence is defined for the set of positive integers:
    n → n/2 (n is even)
    n → 3n + 1 (n is odd)

    Using the rule above and starting with 13, we generate the following sequence:

    13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1
    It can be seen that this sequence (starting at 13 and finishing at 1) contains 10 terms. Although it has not been proved yet (Collatz Problem), it is thought that all starting numbers finish at 1.

    Which starting number, under one million, produces the longest chain?

    NOTE: Once the chain starts the terms are allowed to go above one million.

    La idea es llevar un diccionario con las secuencias que ya haya calculado para ahorrar trabajo.
    El resto es un simple for para iterar todos los posibles numeros y calcular el largo de la secuencia por cada num.
    """

    known_sequences = dict()
    max_so_far = 0
    max_cant = 0

    for i in range(1, 1000000):
        cant = 1
        n = i
        while n > 1:
            if n % 2 == 0:
                n /= 2
                if n in known_sequences:
                    cant += known_sequences[n]
                    break
            else:
                n = 3 * n + 1
                if n in known_sequences:
                    cant += known_sequences[n]
                    break
            cant += 1
        if cant > max_cant:
            max_cant = cant
            max_so_far = i

        known_sequences[i] = cant

    return max_so_far


def problema_15():
    """
    Starting in the top left corner of a 2×2 grid, and only being able to move to the right and down,
    there are exactly 6 routes to the bottom right corner.
    How many such routes are there through a 20×20 grid?

    Cada posicion es igual a la suma de todas las maneras de posibles de llegar a sus inmediatamente previos caminos.
    Por ejemplo, la posicion (3,3) es accesible solamente desde la posicion (2,3) y (3,2).
    Entonces la cantidad total de maneras distinas de llegar a (3,3) = Suma total maneras disitinas de (2,3) y (3,2)
    Como se puede ver lleva una logica recursiva y para cuando se llega a una posicion ubicada en 0(columna o fila),
    a este tipo de posiciones es posible llegar solo de 1 manera distina.
    """

    init_position = (3, 3)
    banned_positions = {(0, 2), (1, 1)}
    visited_positions = dict()
    STOP = -1

    def recursive_unique_paths(position):

        x, y = position
        # Use map to avoid computing several times the same position.
        if position in visited_positions:
            return visited_positions[(x, y)]
        # There are 0 ways of reaching this position
        elif x == STOP or y == STOP or position in banned_positions:
            return 0
        elif position == (0, 0):
            return 1

        # Total number of ways to reach upper position
        up = recursive_unique_paths((x-1, y))
        # Total num of ways to reach left position
        left = recursive_unique_paths((x, y-1))
        # Memoize
        visited_positions[(x-1, y)] = up
        visited_positions[(x, y-1)] = left
        return left + up

    return recursive_unique_paths(init_position)


def problema_16():
    """
    2^15 = 32768 and the sum of its digits is 3 + 2 + 7 + 6 + 8 = 26.
    What is the sum of the digits of the number 2^1000?
    """
    power = int(math.pow(2, 1000))
    power = str(power)
    total = 0

    for char in power:
        total += int(char)

    return total


def problema_17():
    """
    If the numbers 1 to 5 are written out in words: one, two, three, four, five, then there are 3 + 3 + 5 + 4 + 4 = 19 letters used in total.
    If all the numbers from 1 to 1000 (one thousand) inclusive were written out in words, how many letters would be used?
    NOTE: Do not count spaces or hyphens.
    For example, 342 (three hundred and forty-two) contains 23 letters and 115 (one hundred and fifteen) contains 20 letters.
    The use of "and" when writing out numbers is in compliance with British usage.


    La idea es segun la posicion y el valor del numero poder convertirlo(sea a decena, centena) e ir agregando el valor
    de cada uno iterativamente.
    """

    map_of_numbers = {
        "0": 0, "1": 3, "2": 3, "3": 5, "4": 4, "5": 4, "6": 3, "7": 5, "8": 5, "9": 4,
        "10": 3, "11": 6, "12": 6, "13": 8, "14": 8, "15": 7, "16": 7, "17": 9, "18": 8, "19": 8,
        "20": 6, "30": 6, "40": 5, "50": 5, "60": 5, "70": 7, "80": 6, "90": 6,
        "100": 13, "200": 13, "300": 15, "400": 14, "500": 14, "600": 13, "700": 15, "800": 15, "900": 14,
        "1000": 11
    }
    total = 0

    def solve(char, length):
        multiplier = int(math.pow(10, length - 1))
        calc = str(int(char) * multiplier)
        return map_of_numbers[calc]

    for i in range(1, 1001):
        s = str(i)
        n = len(s)
        for j in range(n):
            if n - j == 2 and s[j:] in map_of_numbers:
                total += map_of_numbers[s[j:]]
                break
            else:
                total += solve(s[j], n-j)
    # -27 porque el 100, 200, etc..., los estoy contantdo como "one hundred and" y no deberian tener ese and
    # Son solamente 9 numeros que no cumplen con esa regla, entonces 9*3
    return total - 27



def problema_18():
    """
    Calcular la suma maxima entre todos los caminos posibles hacia arriba.
    """
    triangle = [
        [75],
        [95, 64],
        [17, 47, 82],
        [18, 35, 87, 10],
        [20, 4, 82, 47, 65],
        [19, 1, 23, 75, 3, 34],
        [88, 2, 77, 73, 7, 63, 67],
        [99, 65, 4, 28, 6, 16, 70, 92],
        [41, 41, 26, 56, 83, 40, 80, 70, 33],
        [41, 48, 72, 33, 47, 32, 37, 16, 94, 29],
        [53, 71, 44, 65, 25, 43, 91, 52, 97, 51, 14],
        [70, 11, 33, 28, 77, 73, 17, 78, 39, 68, 17, 57],
        [91, 71, 52, 38, 17, 14, 91, 43, 58, 50, 27, 29, 48],
        [63, 66, 4, 68, 89, 53, 67, 30, 73, 16, 69, 87, 40, 31],
        [4, 62, 98, 27, 23, 9, 70, 98, 73, 93, 38, 53, 60, 4, 23]
    ]

    def calculate_best_option(t, i_0, j_0):
        if i_0 == len(t) - 1:
            return t[i_0][j_0]

        opt1 = t[i_0 + 1][j_0]
        opt2 = t[i_0 + 1][j_0 + 1]
        best_option = max(opt1, opt2)
        return best_option

    for i in range(len(triangle) - 1, -1, -1):
        dummy_row = []
        for j in range(len(triangle[i])):
            # print("{} {}".format(triangle[i][j], calculate_best_option(triangle, i, j)))
            dummy_row.append(calculate_best_option(triangle, i, j))
        print("{}: {}".format(i, dummy_row))
        for k, elem in enumerate(dummy_row):
            if i != len(triangle) - 1:
                triangle[i][k] += elem

    return triangle[0][0]


def problema_19():
    """
    You are given the following information, but you may prefer to do some research for yourself.

    1 Jan 1900 was a Monday.
    Thirty days has September, April, June and November.
    All the rest have thirty-one,
    Saving February alone,
    Which has twenty-eight, rain or shine.
    And on leap years, twenty-nine.
    A leap year occurs on any year evenly divisible by 4, but not on a century unless it is divisible by 400.
    How many Sundays fell on the first of the month during the twentieth century (1 Jan 1901 to 31 Dec 2000)?

    """

    days = {
        1: "TUE", 2: "WED", 3: "THU", 4: "FRI", 5: "SAT", 6: "SUN", 0: "MON"
    }
    months = {
        1: 31, 2: 28, 3: 31, 4: 30, 5: 31, 6: 30,
        7: 31, 8: 31, 9: 30, 10: 31, 11: 30, 12: 31
    }

    total = 0
    acc = 1

    def is_leap_year(y):
        if y % 4 == 0:
            return True
        return False

    def is_sunday(accumulated):
        return days[accumulated % 7] == "SUN"

    def sum_month_days(year, month):
        if is_leap_year(year) and month == 2:
            return 29
        return months[month]

    for year in range(1901, 2001):
        for month in range(1, 13):
            if is_sunday(acc):
                total += 1
            acc += sum_month_days(year, month)

    return total


def problema_20():
    """
    n! means n × (n − 1) × ... × 3 × 2 × 1
    For example, 10! = 10 × 9 × ... × 3 × 2 × 1 = 3628800,
    and the sum of the digits in the number 10! is 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27.
    Find the sum of the digits in the number 100!
    """

    tot = 0

    n = str(math.factorial(100))
    for char in n:
        tot += int(char)

    return tot


def problema_21():
    """
    Let d(n) be defined as the sum of proper divisors of n (numbers less than n which divide evenly into n).
    If d(a) = b and d(b) = a, where a ≠ b, then a and b are an amicable pair and each of a and b are called amicable numbers.
    For example, the proper divisors of 220 are 1, 2, 4, 5, 10, 11, 20, 22, 44, 55 and 110; therefore d(220) = 284. The proper divisors of 284 are 1, 2, 4, 71 and 142; so d(284) = 220.
    Evaluate the sum of all the amicable numbers under 10000.

    """
    total = 0
    nums = set()
    already_computed = {1: 1}

    for i in range(1, 10000):
        factors_i = sum_factors(i, already_computed)
        for j in range(i+1, 10000):

            if factors_i == j and sum_factors(j, already_computed) == i:
                print("{} and {} are amicable".format(i, j))
                if i not in nums:
                    total += i
                if j not in nums:
                    total += j
                nums.add(i)
                nums.add(j)
    return total


def problema_22():
    """
    Using names.txt (right click and 'Save Link/Target As...'), a 46K text file containing over five-thousand first names, begin by sorting it into alphabetical order. Then working out the alphabetical value for each name, multiply this value by its alphabetical position in the list to obtain a name score.
    For example, when the list is sorted into alphabetical order, COLIN, which is worth 3 + 15 + 12 + 9 + 14 = 53, is the 938th name in the list. So, COLIN would obtain a score of 938 × 53 = 49714.
    What is the total of all the name scores in the file?

    """
    def get_names(filename=None):
        with open(filename, "r") as file:
            return file.read()

    names = get_names(os.getcwd() + "/names.txt")
    names = names.split(",")
    ordered_names = []
    for name in names:
        ordered_names.insert(bisect_left(a=ordered_names, x=name[1: -1]), name[1: -1])

    total = 0

    for i, name in enumerate(ordered_names):

        suma_name = 0
        for char in name:
            suma_name += ord(char) - 64
        total += suma_name * (i + 1)

    return total


def problema_23():
    """
    A perfect number is a number for which the sum of its proper divisors is exactly equal to the number.
    For example, the sum of the proper divisors of 28 would be 1 + 2 + 4 + 7 + 14 = 28, which means that 28 is a perfect number.
    A number n is called deficient if the sum of its proper divisors is less than n and it is called abundant if this sum exceeds n.
    As 12 is the smallest abundant number, 1 + 2 + 3 + 4 + 6 = 16,
    the smallest number that can be written as the sum of two abundant numbers is 24. By mathematical analysis,
    it can be shown that all integers greater than 28123 can be written as the sum of two abundant numbers.
    However, this upper limit cannot be reduced any further by analysis even though it is known that the greatest number
    that cannot be expressed as the sum of two abundant numbers is less than this limit.
    Find the sum of all the positive integers which cannot be written as the sum of two abundant numbers.

    """
    upper = 28123
    abundant_numbers = []
    already_computed = {}
    should = 1

    for i in range(2, upper):
        if sum_factors(i, already_computed) > i:
            abundant_numbers.append(i)
        should += i

    s = set()

    for i in range(len(abundant_numbers)):
        for j in range(i, len(abundant_numbers)):
            op = abundant_numbers[i] + abundant_numbers[j]
            if op < upper:
                s.add(abundant_numbers[i] + abundant_numbers[j])

    return should - sum(s)


def problema_24():
    """
    A permutation is an ordered arrangement of objects. For example, 3124 is one possible permutation of the digits
    1, 2, 3 and 4. If all of the permutations are listed numerically or alphabetically, we call it lexicographic order.
    The lexicographic permutations of 0, 1 and 2 are:
    012   021   102   120   201   210
    What is the millionth lexicographic permutation of the digits 0, 1, 2, 3, 4, 5, 6, 7, 8 and 9?

    """
    a = permutations([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
    iter = list(a)[999999]
    str_iter = ""
    for elem in iter:
        str_iter += str(elem)
    return str_iter


def problema_25():
    """
    The Fibonacci sequence is defined by the recurrence relation:
    Fn = Fn−1 + Fn−2, where F1 = 1 and F2 = 1.
    Hence the first 12 terms will be:
    F1 = 1
    F2 = 1
    F3 = 2
    F4 = 3
    F5 = 5
    F6 = 8
    F7 = 13
    F8 = 21
    F9 = 34
    F10 = 55
    F11 = 89
    F12 = 144
    The 12th term, F12, is the first term to contain three digits.

    What is the index of the first term in the Fibonacci sequence to contain 1000 digits?
    """
    n1 = 1
    n2 = 1
    cnt = 1
    while True:
        n1, n2 = n2, n1 + n2
        cnt += 1
        if int(math.log10(n1)) + 1 == 1000:
            return cnt
def problema_26():
    """
    A unit fraction contains 1 in the numerator. The decimal representation of the unit fractions with denominators 2 to 10 are given:
    1/2	= 	0.5
    1/3	= 	0.(3)
    1/4	= 	0.25
    1/5	= 	0.2
    1/6	= 	0.1(6)
    1/7	= 	0.(142857)
    1/8	= 	0.125
    1/9	= 	0.(1)
    1/10	= 	0.1
    Where 0.1(6) means 0.166666..., and has a 1-digit recurring cycle. It can be seen that 1/7 has a 6-digit recurring cycle.
    Find the value of d < 1000 for which 1/d contains the longest recurring cycle in its decimal fraction part.
    """

    for i in range(999, 2, -2):
        if is_prime(i) and find_cyclic_length(i) == i-1:
            return i


def problema_27():
    """
    https://projecteuler.net/problem=27
    """
    constraint_a = (-1000, 1000)
    constraint_b = (-1001, 1001)
    func_template = lambda a0, a1, a2: math.pow(a0, 2) + a0 * a1 + a2
    maximum = 0
    max_factors = ()

    for i in range(constraint_a[0], constraint_a[1]):
        for j in range(constraint_b[0], constraint_b[1]):
            n = 0
            while True:
                res = func_template(n, i, j)
                if not is_prime(res):
                    factors = (i, j)
                    break
                n += 1

            if n > maximum:
                max_factors = factors

            maximum = max(n, maximum)
    return max_factors


def problema_28():
    """
    Starting with the number 1 and moving to the right in a clockwise direction a 5 by 5 spiral is formed as follows:

    21 22 23 24 25
    20  7  8  9 10
    19  6  1  2 11
    18  5  4  3 12
    17 16 15 14 13

    It can be verified that the sum of the numbers on the diagonals is 101.

    What is the sum of the numbers on the diagonals in a 1001 by 1001 spiral formed in the same way?
    """
    """
    Las esquinas son siempre 4(excepto en un 1x1 que es 1), entonces en un 3x3, las esquinas son 1 + 4, en un 5x5 1 + 4 + 4, y asi...
    la diferencia relativa entre esquinas es de cant_de_filas - 1 y la distancia relativa cuando se genera un nuevo contorno
    ENTRE la ESQUINA mas GRANDE del CONTORNO MAS CHICO y la ESQUINA mas CHICA del CONTORNO MAS GRANDE es de cant_de_filas - 1

    Si eso es cierto entonces es una simple formula y no hay que generar ningun tipo de espiral ni nada similar
    """
    valor_centro_espiral = 1
    total = valor_centro_espiral
    cant_filas = 1001
    cant_esquinas = 4
    esquina_max = valor_centro_espiral

    for i in range(3, cant_filas + 1, 2):
        for j in range(cant_esquinas):
            esquina_max += i - 1
            total += esquina_max
    return total


def problema_29():
    """
    Consider all integer combinations of a^b for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:

    2^2=4, 2^3=8, 2^4=16, 2^5=32
    3^2=9, 3^3=27, 3^4=81, 3^5=243
    4^2=16, 4^3=64, 4^4=256, 4^5=1024
    5^2=25, 5^3=125, 5^4=625, 5^5=3125
    If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:

    4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125

    How many distinct terms are in the sequence generated by ab for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?
    """
    res = set()
    for i in range(2, 101):
        for j in range(2, 101):
            res.add(math.pow(i, j))
    return len(res)


def problema_30():
    """
    Surprisingly there are only three numbers that can be written as the sum of fourth powers of their digits:

    1634 = 1^4 + 6^4 + 3^4 + 4^4
    8208 = 8^4 + 2^4 + 0^4 + 8^4
    9474 = 9^4 + 4^4 + 7^4 + 4^4
    As 1 = 1^4 is not a sum it is not included.

    The sum of these numbers is 1634 + 8208 + 9474 = 19316.

    Find the sum of all the numbers that can be written as the sum of fifth powers of their digits.
    """
    # TODO: Calculate upper_bound more precisely, 
    # basically a number might become too big to be computed as the sum of all its digits, 
    # regardless of the digit value
    power_value = 5
    lower_bound = int(math.pow(2, power_value)) 
    upper_bound = int(math.pow(9, power_value)) * power_value
    respuesta = list()

    for i in range(lower_bound, upper_bound + 1):
        digits = get_digits(i)
        suma = 0
        for digit in digits:
            suma += math.pow(digit, power_value)
        if suma == i:
            respuesta.append(suma)

    return int(sum(respuesta))


def problema_31():
    """
    In the United Kingdom the currency is made up of pound (£) and pence (p). There are eight coins in general circulation:

    1p, 2p, 5p, 10p, 20p, 50p, £1 (100p), and £2 (200p).
    It is possible to make £2 in the following way:

    1x£1 + 1x50p + 2x20p + 1x5p + 1x2p + 3x1p
    How many different ways can £2 be made using any number of coins?

    Dynamic programming, por que no me di cuenta?
    """
    coins = [1, 2, 5, 10, 20, 50, 100, 200]
    matrix = [[ 1 for _ in range(len(coins))] for _ in range(200)]

    for i in range(len(matrix)):
        for j in range(len(matrix[i])):
            remainder = (i + 1) - coins[j]
            if remainder >= 0:
                if j > 0 and i > 0:
                    matrix[i][j] = matrix[i][j-1] + matrix[remainder - 1][j]
            elif remainder == 0:
                matrix[i][j] = matrix[i][j-1] + 1
            else:
                if j > 0:
                    matrix[i][j] = matrix[i][j-1]

    return matrix[-1][-1]


def problema_32():
    """
    We shall say that an n-digit number is pandigital if it makes use of all the digits 1 to n exactly once; for example, the 5-digit number, 15234, is 1 through 5 pandigital.

    The product 7254 is unusual, as the identity, 39 × 186 = 7254, containing multiplicand, multiplier, and product is 1 through 9 pandigital.

    Find the sum of all products whose multiplicand/multiplier/product identity can be written as a 1 through 9 pandigital.

    HINT: Some products can be obtained in more than one way so be sure to only include it once in your sum.
    """
    results = dict()

    for i in range(10000):
        for j in range(70):
            result = i * j
            if result > 987654321:
                break
            if check_all_digits(result, i, j):
                if not result in results:
                    results[result] = [set([i, j])]
                else:
                    if set([i, j]) not in results[result]:
                        results[result].append(set([i, j]))
    total = 0
    for key in results:
        total += key

    return total


def problema_33():
    """
    The fraction 49/98 is a curious fraction, as an inexperienced mathematician in attempting to simplify it may incorrectly believe that 49/98 = 4/8, which is correct, is obtained by cancelling the 9s.

    We shall consider fractions like, 30/50 = 3/5, to be trivial examples.

    There are exactly four non-trivial examples of this type of fraction, less than one in value, and containing two digits in the numerator and denominator.

    If the product of these four fractions is given in its lowest common terms, find the value of the denominator.
    """
    def _test(before_num, before_den, after_num, after_den):
        try: 
            if before_num / before_den == after_num / after_den:
                return True
            return False
        except ZeroDivisionError:
            return False
    
    def _int(string):
        try:
            return int(string)
        except ValueError:
            return 0
    terms = list()
    
    for i in range(10, 100):
        for j in range(i, 100):
            if i == j:
                continue
            str_i = str(i)
            str_j = str(j)
            if str_i[0] != "0" and str_i[0] in str_j:
                if _test(
                    i,
                    j,
                    _int(str_i.replace(str_i[0], "")), 
                    _int(str_j.replace(str_i[0], ""))
                ): 
                    terms.append(get_lowest_common_term(i, j))
            elif str_i[1] != "0" and str_i[1] in str_j:
                if _test(
                    i,
                    j,
                    _int(str_i.replace(str_i[1], "")), 
                    _int(str_j.replace(str_i[1], ""))
                ): 
                    terms.append(get_lowest_common_term(i, j))
            else: 
                pass
    num = 1
    den = 1
    for term in terms:
        num *= term[0]
        den *= term[1]
    return get_lowest_common_term(num, den)


def problema_34():
    """
    145 is a curious number, as 1! + 4! + 5! = 1 + 24 + 120 = 145.

    Find the sum of all numbers which are equal to the sum of the factorial of their digits.

    Note: As 1! = 1 and 2! = 2 are not sums they are not included.
    """
    def __find_upper_bound():
        num = math.factorial(9)
        counter = 1
        suma = num
        while True:
            if len(str(num)) < counter:
                break
            suma += num
            counter += 1 
        return suma

    lower_bound = 3
    upper_bound = __find_upper_bound()
    total = 0
    memoized_results = {
        0: math.factorial(0),
        1: math.factorial(1),
        2: math.factorial(2),
        3: math.factorial(3),
        4: math.factorial(4),
        5: math.factorial(5),
        6: math.factorial(6),
        7: math.factorial(7),
        8: math.factorial(8),
        9: math.factorial(9),
    }

    for i in range(lower_bound, upper_bound):
        digits = get_digits(i)
        suma = 0
        for digit in digits:
            suma += memoized_results[digit]
        if suma == i:
            total += i
    return total


def problema_35():
    """
    The number, 197, is called a circular prime because all rotations of the digits: 197, 971, and 719, are themselves prime.

    There are thirteen such primes below 100: 2, 3, 5, 7, 11, 13, 17, 31, 37, 71, 73, 79, and 97.

    How many circular primes are there below one million?
    """
    UPPER_BOUND = 1000000
    LOWER_BOUND = 3
    circular_primes = set({2})

    for i in range(LOWER_BOUND, UPPER_BOUND, 2):
        if i in circular_primes:
            continue
        digits = get_digits(i)
        for digit in digits:
            if digit % 2 == 0:
                break
        prime = True
        comb_list = generate_rotation_nums(digits)
        comb_list_num = list()
        for comb in comb_list:
            comb_list_num.append(comb)
            if not is_prime(comb):
                prime = False
                break
            comb_list_num.append(comb)
        if prime:
            for comb in comb_list_num:
                circular_primes.add(comb)
    print(circular_primes)
    return len(circular_primes)


def problema_36():
    """
    The decimal number, 585 = 1001001001 base 2 (binary), is palindromic in both bases.

    Find the sum of all numbers, less than one million, which are palindromic in base 10 and base 2.

    (Please note that the palindromic number, in either base, may not include leading zeros.)
    """
    UPPER_BOUND = 1000000
    total = 0

    for i in range(1, UPPER_BOUND):
        is_palindrome_bin, is_palindrome_num = is_palindrome(bin(i)[2:]), is_palindrome_number(i)
        if is_palindrome_bin and is_palindrome_num:
            total += i
    
    return total
        

def problema_37():
    """
    The number 3797 has an interesting property. Being prime itself, it is possible to continuously remove digits from left to right,
    and remain prime at each stage: 3797, 797, 97, and 7. Similarly we can work from right to left: 3797, 379, 37, and 3.

    Find the sum of the only eleven primes that are both truncatable from left to right and right to left.

    NOTE: 2, 3, 5, and 7 are not considered to be truncatable primes.
    """
    total_primes = 11
    found_so_far = 0
    primes = []
    check_number = 11
    not_allowed_numbers = {4,6,8,0}

    def form_all_possible_combinations(num, not_allowed_numbers):
        """
        12, 1, 2
        123, 12, 1, 23, 3
        [1,2,3] 1 12 123 23 3
        1234, 123, 12, 1, 234, 34, 4
        """
        digits = get_digits(num)
        digits_length = len(digits)
        
        for digit in digits:
            if digit in not_allowed_numbers:
                return False
        
        chunk_length = 1

        while chunk_length < digits_length:
            left, right = digits[0:chunk_length], digits[-1 -chunk_length + 1:]
            left_total = 0
            right_total = 0
            for num in left:
                left_total *= 10
                left_total += num
            if not is_prime(left_total):
                return False
                
            for num in right:
                right_total *= 10
                right_total += num
            if not is_prime(right_total):
                return False
            chunk_length += 1

        total = 0
        for num in digits:
            total *= 10
            total += num
        
        return is_prime(total)


    while found_so_far < total_primes:
        if form_all_possible_combinations(check_number, not_allowed_numbers):
            primes.append(check_number)
            found_so_far += 1
            print(check_number)
        check_number += 2
        if check_number > 100:
            not_allowed_numbers.add(5)

    return sum(primes)


def problema_38():
    """
    Take the number 192 and multiply it by each of 1, 2, and 3:

    192 x 1 = 192
    192 x 2 = 384
    192 x 3 = 576
    By concatenating each product we get the 1 to 9 pandigital, 192384576. We will call 192384576 the concatenated product of 192 and (1,2,3)

    The same can be achieved by starting with 9 and multiplying by 1, 2, 3, 4, and 5, giving the pandigital, 
    918273645, which is the concatenated product of 9 and (1,2,3,4,5).

    What is the largest 1 to 9 pandigital 9-digit number that can be formed as the concatenated product of an integer with (1,2, ... , n) where n > 1?
    """
    def check_pandigital(num):
        all_digits = {"1","2","3","4","5","6","7","8", "9"}
        if len(num) != 9:
            return False
        
        for char in num:
            if char == "0":
                return False
            try:
                all_digits.remove(char)
            except KeyError:
                return False
        return True

    starting_number = 9
    to_beat = 918273645
    best = 0
    while best <= to_beat:
        i = 1
        curr = ""
        while True:
            if check_pandigital(curr):
                print(f"current number: {curr}, start number: {starting_number}")
                best = max(to_beat, best)
            if curr and int(curr) > 1000000000:
                break
            curr += str(starting_number * i)
            i += 1
        starting_number += 1

    return best



def problema_52():
    """
    It can be seen that the number, 125874, and its double, 251748, contain exactly the same digits, but in a different order.

    Find the smallest positive integer, x, such that 2x, 3x, 4x, 5x, and 6x, contain the same digits.
    """
    no_of_digits = 1
    while True:
        for i in get_loop_range(no_of_digits):
            if check_if_all_digits_are_the_same(i):
                return i
        no_of_digits += 1
